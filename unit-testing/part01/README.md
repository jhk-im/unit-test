# Part 1

## 더 큰 그림

```txt
* 단위 테스트의 목표
* 고품질 테스트와 저품질 테스트
* 단위 테스트의 정의
* 단위 테스트의 기본 주제
```

### 1 : 단위 테스트의 목표

> 단위 테스트는 기술적인 부분을 익히는 것에 그치지 않는다. 단순히 테스트를 작성하는 것 보다 큰 범주이며 테스트에 드는 노력을 가능한 줄이고 그에 따른 이득을 최대화해야 한다.

#### 1-1 : 단위 테스트 현황

`그냥 쓰고 버리는 프로젝트가 아니라면 단위 테스트는 이제 필수이다.`

`상당수의 기업용 어플리케이션 개발 프로젝트에서 단위 테스트와 통합 테스트를 통해 좋은 Code coverage를 달성하고 있다.`

`단위 테스트를 작성해야 하는가?에서 좋은 단위 테스트를 작성하는 것은 어떤 의미인가?로 논쟁이 바뀌었다.`

```txt
기업용 어플리케이션의 특징

* 높은 비즈니스 복잡도
* 긴 프로젝트 수명
* 중간 크기의 데이터
* 낮은 수준에서 중간 수준 정도의 성능 요구
```

#### 1-2 : 단위 테스트의 궁극적인 목표

> 프로젝트의 `지속 가능`한 성장을 가능하게 하는 것이며 `지속 가능`하다는 것이 핵심이다. 테스트가 없는 프로젝트의 경우 시작은 유리하지만 시간이 지날수록 진척이 없을 정도로 느려진다. 이러한 현상을 `software entropy`라고 하며 풀질을 떨어뜨리는 코드 형태로 나타난다.

테스트는 안전망 역할 및 회귀(regression)에 대한 보험을 제공하는 도구이다. 테스트는 초반에 상당한 노력이 필요하다는 단점이 있다. 다만 `지속성`, `확장성`, `장기적 개발속도`를 위해선 반드시 필요하다.

`회귀(regression)`는 버그와 동의어이며 바꿔서 사용할 수 있다.

#### 1-3 : 고품질 테스트와 저품질 테스트

> 테스트도 코드이다. 애플리케이션의 정확성을 보장하는 것을 목표로 하는 코드 베이스의 일부이다. 그러므로 단위 테스트도 버그에 취약하며 유지보수가 필요하다. 저품질의 테스트 코드도 도움이 될 수 있지만 지속 가능한 성장에는 도움이 되지 못한다. 고품질 테스트 만이 테스트 스위트에 남을 수 있다.

```txt
고품질 테스트란?

* 기반 코드 리팩터링시 테스트도 리팩터링
* 각 코드 변경 시 테스트 실행
* 테스트에서 경고 발생 시 처리
* 기반 코드를 이해하려고 할 때 테스트를 읽는데 시간을 투자
```

#### 1-4 : 테스트 스위트 풀질 측정 커버리지 지표

>커버리지 지표는 테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타낸다. 가장 많이 사용되는 지표는 `code coverage`와 `branch coverage`이다. 일반적으로 커버리지 숫자가 높을수록 좋다.

#### Code Coverage

`Test Coverage`로도 불린다.

```txt
* 제품 코드 라인 수 = 테스트 스위트가 실행한 코드 라인수
* 전체 라인 수 = 제품 코드베이스의 전체 라인 수
CodeCoverage(TestCoverage) = 제품 코드 라인 수 / 전체 라인 수
```

```c#
public static bool IsStringLong(string input) {
    if (input.Length > 5)
        return true; // 테스트가 다루지 않는 영역
    return false;
}

public void Test() {
    bool result = IsStringLong("abc");
    Assert.Equal(false, result);
}

// 코드 커버리지 지표 -> 4/5 = 0.8 = 80%
```

```c#
public static bool IsStringLong(string input) {
    return input.Length > 5;
}

public void Test() {
    bool result = IsStringLong("abc");
    Assert.Equal(false, result);
}

// 코드 커버리지 지표 ->  3/3 = 100%
```

> 해당 예제는 테스트 스위트를 개선하지 않았다. 코드를 더 작게 한다고 트스트 스위트의 가치나 코드베이스의 유지 보수성이 변경되지 않았다는 점을 기억하자.

#### Branch Coverage

Code Coverage의 단점을 극복 하는데 도움이 되므로 보다 정확한 결과를 제공한다.

```txt
* 원시 코드 라인 수를 사용하는 데신 if, switch 와 같은 제어 구조에 중점을 둠
* 통과 분기 = 테스트 스위트가 수행하는 코드 분기 수
* 전체 분기 수 = 제품 코드베이스의 전체 분기 수
BranchCoverage = 통과 분기 / 전체 분기 수
```

```c#
public static bool IsStringLong(string input) {
    return input.Length > 5;
}

public void Test() {
    bool result = IsStringLong("abc");
    Assert.Equal(false, result);
}

// IsStringLong 메서드에 문자열 인수의 길이에 대한 분기가 있다. 테스트는 이러한 분기중 하나만 적용된다.
// 분기 커버리지 지표 -> 1/2 = 0.5 = 50%
```

> 분기 커버리지는 분기 개수만 다루며, 해당 분기를 구현하는 데 얼마나 코드가 필요한지는 고려하지 않는다.

#### 1-5 : 커버리지 지표에 대한 문제점

* `모든 결과를 검증한다고 보장할 수 없음`
* `외부 라이브러리 코드 경로를 고려할 수 없음`
