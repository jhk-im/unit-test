# Part 1

## 더 큰 그림

```txt
* 단위 테스트의 목표
* 고품질 테스트와 저품질 테스트
* 단위 테스트의 정의
* 단위 테스트의 기본 주제
```

### 1 : 단위 테스트의 목표

> 단위 테스트는 기술적인 부분을 익히는 것에 그치지 않는다. 단순히 테스트를 작성하는 것 보다 큰 범주이며 테스트에 드는 노력을 가능한 줄이고 그에 따른 이득을 최대화해야 한다.

#### 1-1 : 단위 테스트 현황

`그냥 쓰고 버리는 프로젝트가 아니라면 단위 테스트는 이제 필수이다.`

`상당수의 기업용 어플리케이션 개발 프로젝트에서 단위 테스트와 통합 테스트를 통해 좋은 Code coverage를 달성하고 있다.`

`단위 테스트를 작성해야 하는가?에서 좋은 단위 테스트를 작성하는 것은 어떤 의미인가?로 논쟁이 바뀌었다.`

```txt
기업용 어플리케이션의 특징

* 높은 비즈니스 복잡도
* 긴 프로젝트 수명
* 중간 크기의 데이터
* 낮은 수준에서 중간 수준 정도의 성능 요구
```

#### 1-2 : 단위 테스트의 궁극적인 목표

> 프로젝트의 `지속 가능`한 성장을 가능하게 하는 것이며 `지속 가능`하다는 것이 핵심이다. 테스트가 없는 프로젝트의 경우 시작은 유리하지만 시간이 지날수록 진척이 없을 정도로 느려진다. 이러한 현상을 `software entropy`라고 하며 풀질을 떨어뜨리는 코드 형태로 나타난다.

테스트는 안전망 역할 및 회귀(regression)에 대한 보험을 제공하는 도구이다. 테스트는 초반에 상당한 노력이 필요하다는 단점이 있다. 다만 `지속성`, `확장성`, `장기적 개발속도`를 위해선 반드시 필요하다.

`회귀(regression)`는 버그와 동의어이며 바꿔서 사용할 수 있다.

#### 1-3 : 고품질 테스트와 저품질 테스트

> 테스트도 코드이다. 애플리케이션의 정확성을 보장하는 것을 목표로 하는 코드 베이스의 일부이다. 그러므로 단위 테스트도 버그에 취약하며 유지보수가 필요하다. 저품질의 테스트 코드도 도움이 될 수 있지만 지속 가능한 성장에는 도움이 되지 못한다. 고품질 테스트 만이 테스트 스위트에 남을 수 있다.

```txt
고품질 테스트란?

* 기반 코드 리팩터링시 테스트도 리팩터링
* 각 코드 변경 시 테스트 실행
* 테스트에서 경고 발생 시 처리
* 기반 코드를 이해하려고 할 때 테스트를 읽는데 시간을 투자
```

#### 1-4 : 테스트 스위트 풀질 측정 커버리지 지표

>커버리지 지표는 테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타낸다. 가장 많이 사용되는 지표는 `code coverage`와 `branch coverage`이다. 일반적으로 커버리지 숫자가 높을수록 좋다.

#### Code Coverage

`Test Coverage`로도 불린다.

```txt
* 제품 코드 라인 수 = 테스트 스위트가 실행한 코드 라인수
* 전체 라인 수 = 제품 코드베이스의 전체 라인 수
CodeCoverage(TestCoverage) = 제품 코드 라인 수 / 전체 라인 수
```

```c#
public static bool IsStringLong(string input) {
    if (input.Length > 5)
        return true; // 테스트가 다루지 않는 영역
    return false;
}

public void Test() {
    bool result = IsStringLong("abc");
    Assert.Equal(false, result);
}

// 코드 커버리지 지표 -> 4/5 = 0.8 = 80%
```

```c#
public static bool IsStringLong(string input) {
    return input.Length > 5;
}

public void Test() {
    bool result = IsStringLong("abc");
    Assert.Equal(false, result);
}

// 코드 커버리지 지표 ->  3/3 = 100%
```

> 해당 예제는 테스트 스위트를 개선하지 않았다. 코드를 더 작게 한다고 트스트 스위트의 가치나 코드베이스의 유지 보수성이 변경되지 않았다는 점을 기억하자.

#### Branch Coverage

Code Coverage의 단점을 극복 하는데 도움이 되므로 보다 정확한 결과를 제공한다.

```txt
* 원시 코드 라인 수를 사용하는 데신 if, switch 와 같은 제어 구조에 중점을 둠
* 통과 분기 = 테스트 스위트가 수행하는 코드 분기 수
* 전체 분기 수 = 제품 코드베이스의 전체 분기 수
BranchCoverage = 통과 분기 / 전체 분기 수
```

```c#
public static bool IsStringLong(string input) {
    return input.Length > 5;
}

public void Test() {
    bool result = IsStringLong("abc");
    Assert.Equal(false, result);
}

// IsStringLong 메서드에 문자열 인수의 길이에 대한 분기가 있다. 테스트는 이러한 분기중 하나만 적용된다.
// 분기 커버리지 지표 -> 1/2 = 0.5 = 50%
```

> 분기 커버리지는 분기 개수만 다루며, 해당 분기를 구현하는 데 얼마나 코드가 필요한지는 고려하지 않는다.

#### 1-5 : 커버리지 지표에 대한 문제점

* `모든 결과를 검증한다고 보장할 수 없음`
  * 커버리지 지표는 일부 실행 된 것만 보장함
  * 검증이 전혀 없는 테스트의 경우도 있음
* `외부 라이브러리 코드 경로를 고려할 수 없음`
  * 커버리지 지표는 외부 라이브러리가 통과하는 코드 경로를 고려하지 않음
  * 수 많은 예외상황(edge case)을 테스트에서 확인할 방법이 없음

> 커버리지 지표로는 테스트가 철저한지 혹은 충분한지 알 수 없다. 결국 고품질/저품질 테스트를 구별할 수 없다는 의미이다. 단위 테스트는 그 자체로 충분히 어렵기 때문에 커버리지 숫자를 강요하는 경우 적절한 단위 테스트 달성이 어려워진다. 커버리지 측정은 품질 테스트 스위트로 가는 첫 걸음 정도로 생각하자.

#### 1-6 : 성공적인 테스트 스위트

```txt
성공적인 테스트 스위트의 특징

* 개발 주기에 통합되어 있음
* 코드베이스에서 가장 중요한 부분만을 대상으로 함
* 최소한의 유지비로 최대한의 가치를 끌어냄
```

#### `개발 주기에 통합되어 있음`

자동화 테스트의 방법은 끊임없이 하는 것뿐이므로 모든 테스트는 개발 주기에 통합되어야 한다. 이상적으로 아무리 작은 코드 변경이라도 실행되어야 한다.

#### `코드 베이스에서 가장 중요한 부분만을 대상으로 함`

대부분의 애플리케이션에서 가장 중요한 부분은 비즈니스 로직(도메인 모델)이 있는 부분이다. 비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다. 도메인 모델을 다른 애플리케이션의 문제와 분리해야 도메인 모델에만 집중할 수 있다.

```txt
비즈니스 로직 이외의 범주
* 인프라 코드
* 데이터베이스 or 서드파티 시스템과 같은 외부 서비스 및 종속성
* 모든 것을 하나로 묶는 코드

이 중 일부는 단위 테스트를 철저히 해야할 수 있지만 일반적으로 도메인 모델에 초점이 맞춰져 있어야 한다.
```

#### `최소 유지비로 최대 가치를 끌어냄`

가장 어려우면서 가장 핵심이 되는 부분이다.

```txt
* 가치 있는 테스트와 가치가 낮은 테스트 식별하기
가치가 높은 테스트를 식별하기 위해선 `frame of reference`가 필요하다. 

* 가치 있는 테스트 작성하기
가치 있는 테스트를 작헝하기 위해선 코드 설계 기술도 알아야 한다. 
단위 테스트와 기반 코드는 서로 얽혀 있으므로 코드베이스에 노력을 많이 기울여야 가치있는 테스트를 작성할 수 있다.
```
